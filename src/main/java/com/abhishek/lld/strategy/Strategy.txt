Strategy Pattern : 

The Strategy pattern is a behavioral design pattern that defines a family 
of algorithms, encapsulates each one, and makes them interchangeable. This 
pattern allows the algorithm to vary independently from clients that use it 
The Strategy pattern is useful when you need to select an algorithm at runtime

Strategy is a behavioral design pattern that lets you define a family of 
algorithms, put each of them into a separate class, and make their objects 
interchangeable The Strategy pattern suggests that you take a class that does 
something specific in a lot of different ways and extract all of these algorithms 
into separate classes called strategies, The original class, called context, must 
have a field for storing a reference to one of the strategies. The context delegates 
the work to a linked strategy object instead of executing it on its own The context 
isn’t responsible for selecting an appropriate algorithm for the job. Instead, the 
client passes the desired strategy to the context. In fact, the context doesn’t know 
much about strategies. It works with all strategies through the same generic interface, 
which only exposes a single method for triggering the algorithm encapsulated within the 
selected strategy, This way the context becomes independent of concrete strategies, so 
you can add new algorithms or modify existing ones without changing the code of the 
context or other strategies

Key Concepts of Strategy Pattern : 
Strategy Interface : 
Defines a common interface for all supported algorithms

Concrete Strategies : 
Implement the strategy interface with specific algorithms

Context : 
Maintains a reference to a strategy object and allows 
clients to set or change the strategy at runtime

Example: Payment System
Let's create an example of a payment system, where the payment 
method can be selected at runtime (e.g Credit Card, PayPal, Bitcoin)

Use Cases of Strategy Pattern : 
Sorting Algorithms : 
Switching between different sorting algorithms (e.g., quicksort, mergesort, bubblesort) 
based on the data or user preference

Compression Algorithms: 
Switching between different compression algorithms (e.g., ZIP, RAR, GZIP) for file compression

Pathfinding Algorithms: 
Choosing different pathfinding algorithms (e.g., A*, Dijkstra) for navigation systems

Payment Methods: Selecting different payment methods in an e-commerce system

Conclusion : 
The Strategy pattern allows you to define a family of algorithms, encapsulate 
each one, and make them interchangeable. In this example, we implemented a 
payment system where the payment method can be selected at runtime, demonstrating 
the Strategy pattern's flexibility and ability to vary algorithms independently 
from the clients that use them. This pattern helps keep the code clean and maintainable 
by separating algorithm implementation from the context that uses it

