Decorator : 

Also known as Wrapper, Decorator is a structural design pattern that lets you attach 
new behaviors to objects by placing these objects inside special wrapper objects that 
contain the behaviors

The Decorator pattern is a structural design pattern that allows behavior to be added 
to individual objects, dynamically, without affecting the behavior of other objects 
from the same class, Decorators provide a flexible alternative to subclassing for 
extending functionality

Key Concepts of Decorator Pattern : 

Component: The interface or abstract class defining the object being decorated

Concrete Component: The class representing the core object to which additional 
					responsibilities can be attached

Decorator: The abstract class implementing the component interface and containing 
		   a reference to a component object.

Concrete Decorators: The classes extending the decorator class and adding new behaviors

Usecase : 
Let's create an example to demonstrate the Decorator pattern. We'll use a scenario 
where we have a basic text editor, and we want to add additional functionalities 
like spell checking and text compression

Use Cases of Decorator Pattern : 

GUI Frameworks: Adding functionalities like borders, scrollbars, or shadows to UI components

I/O Streams: Enhancing file I/O operations with buffering, encryption, or compression

Logging: Adding logging functionality to classes without changing the original code

Notifications: Enhancing notification systems with additional features like email, 
				SMS, or push notifications.

Problem : 
Imagine that you’re working on a notification library which lets other programs 
notify their users about important events, The initial version of the library 
was based on the Notifier class that had only a few fields, a constructor and 
a single send method. The method could accept a message argument from a client 
and send the message to a list of emails that were passed to the notifier via 
its constructor. A third-party app which acted as a client was supposed to 
create and configure the notifier object once, and then use it each time 
something important happened

At some point, you realize that users of the library expect more than just 
email notifications. Many of them would like to receive an SMS about critical 
issues. Others would like to be notified on Facebook and, of course, the corporate 
users would love to get Slack notifications.

How hard can that be? You extended the Notifier class and put the additional 
notification methods into new subclasses. Now the client was supposed to 
instantiate the desired notification class and use it for all further notifications
But then someone reasonably asked you, “Why can’t you use several notification types 
at once? If your house is on fire, you’d probably want to be informed through every 
channel.” You tried to address that problem by creating special subclasses which 
combined several notification methods within one class. However, it quickly became 
apparent that this approach would bloat the code immensely, not only the library code 
but the client code as well

You have to find some other way to structure notifications classes 
so that their number won’t accidentally break some Guinness record.

Solution :
Extending a class is the first thing that comes to mind when you need to alter 
an object’s behavior, However, inheritance has several serious caveats that you 
need to be aware of, Inheritance is static. You can’t alter the behavior of an 
existing object at runtime. You can only replace the whole object with another 
one that’s created from a different subclass Subclasses can have just one parent 
class. In most languages, inheritance doesn’t let a class inherit behaviors of 
multiple classes at the same time One of the ways to overcome these caveats is 
by using Aggregation or Composition  instead of Inheritance. Both of the alternatives 
work almost the same way: one object has a reference to another and delegates it some 
work, whereas with inheritance, the object itself is able to do that work, inheriting 
the behavior from its superclass With this new approach you can easily substitute the 
linked “helper” object with another, changing the behavior of the container at runtime 
An object can use the behavior of various classes, having references to multiple objects 
and delegating them all kinds of work. Aggregation/composition is the key principle behind 
many design patterns, including Decorator

Conclusion : 
The Decorator pattern allows you to dynamically add behaviors to objects without 
affecting other objects of the same class. It provides a flexible alternative to 
subclassing for extending functionality. In this example, we demonstrated how to 
add functionalities like spell checking, text compression, and encryption to a 
simple text editor using the Decorator pattern. By using decorators, we can mix 
and match functionalities as needed, promoting a more maintainable and extensible 
codebase




